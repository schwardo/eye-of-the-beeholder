<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Eye of the Bee-holder</title>
<style>
:root {
  --bg: #FEF9E7;
  --bg2: #FFF8DC;
  --gold: #DAA520;
  --gold-light: #FFD54F;
  --gold-dark: #8B6914;
  --brown: #3E2723;
  --brown-light: #6D4C41;
  --orange: #FF8C00;
  --cream: #FFFDF5;
  --green: #4CAF50;
  --red: #E53935;
  --blue: #1976D2;
  --hex-size: 72px;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background: var(--bg);
  color: var(--brown);
  min-height: 100vh;
}
#app { max-width: 1200px; margin: 0 auto; padding: 10px; }
h1 { color: var(--gold-dark); text-align: center; font-size: 1.8em; margin-bottom: 2px; }
h1 small { font-size: 0.5em; color: var(--brown-light); display: block; font-weight: normal; }
.tabs {
  display: flex; gap: 0; margin: 10px 0; border-bottom: 3px solid var(--gold);
}
.tab {
  padding: 8px 24px; cursor: pointer; background: var(--bg2);
  border: 2px solid var(--gold); border-bottom: none; border-radius: 8px 8px 0 0;
  font-weight: bold; color: var(--brown-light); transition: all 0.2s;
}
.tab.active { background: var(--gold); color: white; }
.tab:hover:not(.active) { background: var(--gold-light); }
.screen { display: none; }
.screen.active { display: block; }

/* Setup */
.setup-section { background: white; border-radius: 12px; padding: 20px; margin: 15px 0; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
.setup-section h2 { color: var(--gold-dark); margin-bottom: 12px; font-size: 1.2em; }
.player-row {
  display: flex; align-items: center; gap: 12px; padding: 8px;
  border-bottom: 1px solid #eee; flex-wrap: wrap;
}
.player-row:last-child { border-bottom: none; }
.player-row label { font-weight: bold; min-width: 80px; }
.player-row input, .player-row select {
  padding: 6px 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 0.95em;
}
.player-row input:focus, .player-row select:focus { border-color: var(--gold); outline: none; }
.btn {
  padding: 10px 24px; border: none; border-radius: 8px; font-size: 1em;
  font-weight: bold; cursor: pointer; transition: all 0.2s;
}
.btn-primary { background: var(--gold); color: white; }
.btn-primary:hover { background: var(--orange); }
.btn-secondary { background: #eee; color: var(--brown); }
.btn-secondary:hover { background: #ddd; }
.btn-danger { background: var(--red); color: white; }
.btn-small { padding: 5px 12px; font-size: 0.85em; }
.btn:disabled { opacity: 0.5; cursor: not-allowed; }
.btn-group { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 10px; }

/* Game Board */
.game-header {
  display: flex; justify-content: space-between; align-items: center;
  background: linear-gradient(135deg, var(--gold-dark), var(--gold));
  color: white; padding: 10px 20px; border-radius: 10px; margin-bottom: 10px;
  flex-wrap: wrap; gap: 8px;
}
.game-header .phase-info { font-size: 1.1em; font-weight: bold; }
.game-header .round-info { font-size: 0.9em; opacity: 0.9; }
.scores-bar {
  display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 10px;
}
.score-chip {
  background: white; border-radius: 20px; padding: 5px 14px;
  font-size: 0.9em; box-shadow: 0 1px 4px rgba(0,0,0,0.15);
  border: 2px solid transparent;
}
.score-chip.winner { border-color: var(--gold); background: var(--gold-light); }
.score-chip.current { border-color: var(--blue); }
.score-chip .name { font-weight: bold; }
.score-chip .pts { color: var(--gold-dark); font-weight: bold; }
.score-chip .strategy-tag { font-size: 0.75em; color: #999; margin-left: 4px; }

/* Facet Tiles */
.board-area {
  display: flex; gap: 20px; margin-bottom: 10px; align-items: flex-start;
  flex-wrap: wrap;
}
.facets-container {
  background: white; border-radius: 12px; padding: 15px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1); flex: 1; min-width: 300px;
}
.facets-container h3 { text-align: center; font-size: 0.95em; color: var(--brown-light); margin-bottom: 10px; }
.facets-row {
  display: flex; justify-content: center; gap: 6px; flex-wrap: wrap;
}
.facet-tile {
  width: 90px; text-align: center; padding: 8px 4px;
  border-radius: 10px; border: 3px solid #ddd; cursor: default;
  transition: all 0.3s; position: relative; background: var(--cream);
}
.facet-tile .slot-num {
  position: absolute; top: -8px; left: 50%; transform: translateX(-50%);
  background: var(--gold); color: white; font-size: 0.7em; font-weight: bold;
  padding: 1px 7px; border-radius: 10px;
}
.facet-tile .attr-name { font-size: 0.7em; color: #999; margin-bottom: 2px; }
.facet-tile .attr-value {
  font-size: 0.95em; font-weight: bold; padding: 3px 6px;
  border-radius: 6px; display: inline-block;
}
.facet-tile.slot-1 { border-color: var(--gold); box-shadow: 0 0 8px rgba(218,165,32,0.4); }
.facet-tile.slot-2 { border-color: var(--gold-light); }
.facet-tile.clickable { cursor: pointer; }
.facet-tile.clickable:hover { transform: scale(1.05); border-color: var(--blue); }
.facet-tile.selected { border-color: var(--blue); box-shadow: 0 0 8px rgba(25,118,210,0.4); }
.facet-tile.highlight { border-color: var(--orange); box-shadow: 0 0 8px rgba(255,140,0,0.4); }
.qf-indicator {
  text-align: center; font-size: 0.8em; margin-top: 8px; color: var(--gold-dark); font-weight: bold;
}

/* Cards */
.hand-area {
  background: white; border-radius: 12px; padding: 15px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 10px;
}
.hand-area h3 { font-size: 0.95em; color: var(--brown-light); margin-bottom: 10px; }
.cards-row {
  display: flex; gap: 8px; flex-wrap: wrap; justify-content: center;
}
.bee-card {
  width: 140px; border: 3px solid #ddd; border-radius: 10px;
  padding: 6px; cursor: default; transition: all 0.2s;
  background: var(--cream); font-size: 0.8em;
}
.bee-card .bee-img {
  width: 100%; border-radius: 6px; overflow: hidden;
  margin-bottom: 4px; line-height: 0;
}
.bee-card .bee-img img {
  width: 100%; height: auto; display: block;
  border-radius: 6px;
}
.bee-card.mini { width: 120px; }
.bee-card.mini .bee-img img { width: 100%; }
.bee-card .bee-name {
  font-weight: bold; font-size: 0.8em; text-align: center;
  margin-bottom: 4px; color: var(--brown); min-height: 2.2em;
  line-height: 1.1;
}
.bee-card .attrs { display: flex; flex-direction: column; gap: 2px; }
.bee-card .attr-row {
  display: flex; justify-content: space-between; align-items: center;
  padding: 1px 4px; border-radius: 4px; font-size: 0.85em;
}
.bee-card .attr-row .a-label { color: #999; font-size: 0.8em; }
.bee-card .attr-row .a-value { font-weight: bold; }
.bee-card .attr-row.match { background: #E8F5E9; }
.bee-card .attr-row.mismatch { background: #FFEBEE; }
.bee-card.clickable { cursor: pointer; }
.bee-card.clickable:hover { transform: translateY(-4px); border-color: var(--gold); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
.bee-card.selected { border-color: var(--blue); background: #E3F2FD; transform: translateY(-4px); }
.bee-card.winner { border-color: var(--gold); background: #FFF9C4; box-shadow: 0 0 12px rgba(218,165,32,0.5); }
.bee-card.eliminated { opacity: 0.4; border-color: var(--red); }
.bee-card.facedown {
  background: repeating-linear-gradient(45deg, var(--gold-light), var(--gold-light) 5px, var(--gold) 5px, var(--gold) 10px);
  min-height: 180px;
}
.bee-card.facedown .bee-name, .bee-card.facedown .attrs, .bee-card.facedown .bee-img { visibility: hidden; }
.bee-card .score-badge {
  text-align: center; font-size: 0.75em; color: var(--gold-dark);
  margin-top: 4px; font-weight: bold;
}

/* Action Area */
.action-area {
  background: white; border-radius: 12px; padding: 15px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 10px;
  text-align: center;
}
.action-area h3 { color: var(--gold-dark); margin-bottom: 10px; }
.action-area p { margin-bottom: 8px; color: var(--brown-light); }

/* Draft */
.draft-tiles {
  display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;
  margin: 10px 0;
}
.draft-tile {
  border: 3px solid #ddd; border-radius: 10px; padding: 10px 16px;
  cursor: pointer; transition: all 0.2s; background: var(--cream);
  text-align: center;
}
.draft-tile:hover { border-color: var(--gold); transform: scale(1.05); }
.draft-tile.selected { border-color: var(--blue); background: #E3F2FD; }
.draft-tile .dt-name { font-weight: bold; font-size: 0.95em; }
.side-choice {
  display: flex; gap: 10px; justify-content: center; margin: 10px 0;
}
.side-btn {
  padding: 10px 20px; border: 3px solid #ddd; border-radius: 10px;
  cursor: pointer; font-weight: bold; font-size: 1em;
  background: var(--cream); transition: all 0.2s;
}
.side-btn:hover { border-color: var(--gold); background: var(--gold-light); }

/* Played Cards */
.played-area { margin: 10px 0; }
.played-cards-row {
  display: flex; gap: 12px; justify-content: center; flex-wrap: wrap;
}
.played-card-wrapper { text-align: center; }
.played-card-wrapper .player-label {
  font-size: 0.85em; font-weight: bold; margin-bottom: 4px;
  color: var(--brown-light);
}

/* Game Log */
.game-log {
  background: white; border-radius: 12px; padding: 10px 15px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 10px;
  max-height: 200px; overflow-y: auto;
}
.game-log h3 { font-size: 0.85em; color: var(--brown-light); margin-bottom: 6px; }
.log-entry { font-size: 0.8em; padding: 2px 0; border-bottom: 1px solid #f5f5f5; }
.log-entry:last-child { border-bottom: none; }
.log-entry.important { font-weight: bold; color: var(--gold-dark); }

/* Manipulation */
.manip-info {
  background: #FFF3E0; border-radius: 8px; padding: 8px 12px;
  margin: 8px 0; font-size: 0.9em;
}
.manip-modes { display: flex; gap: 10px; justify-content: center; margin: 10px 0; }
.mode-btn {
  padding: 8px 20px; border: 3px solid #ddd; border-radius: 8px;
  cursor: pointer; font-weight: bold; background: var(--cream); transition: all 0.2s;
}
.mode-btn:hover { border-color: var(--gold); }
.mode-btn.active { border-color: var(--blue); background: #E3F2FD; }

/* Simulation */
.sim-config { display: flex; flex-wrap: wrap; gap: 15px; align-items: flex-end; }
.sim-field { display: flex; flex-direction: column; gap: 4px; }
.sim-field label { font-size: 0.85em; font-weight: bold; color: var(--brown-light); }
.sim-field select, .sim-field input {
  padding: 6px 10px; border: 2px solid #ddd; border-radius: 6px;
}
.sim-results { margin-top: 15px; }
.sim-results table {
  width: 100%; border-collapse: collapse; font-size: 0.9em;
}
.sim-results th, .sim-results td {
  padding: 8px 12px; text-align: left; border-bottom: 1px solid #eee;
}
.sim-results th { background: var(--gold-light); color: var(--brown); font-weight: bold; }
.sim-results tr:hover { background: #FFF8E1; }
.progress-bar {
  width: 100%; height: 24px; background: #eee; border-radius: 12px;
  overflow: hidden; margin: 10px 0;
}
.progress-fill {
  height: 100%; background: linear-gradient(90deg, var(--gold), var(--orange));
  transition: width 0.2s; border-radius: 12px; display: flex;
  align-items: center; justify-content: center;
  font-size: 0.75em; font-weight: bold; color: white;
}

/* Pass and Play */
.pass-screen {
  text-align: center; padding: 40px 20px;
}
.pass-screen h2 { color: var(--gold-dark); margin-bottom: 10px; }
.pass-screen p { color: var(--brown-light); margin-bottom: 20px; }

/* Game Over */
.game-over {
  text-align: center; padding: 30px;
}
.game-over h2 { color: var(--gold-dark); font-size: 1.8em; margin-bottom: 10px; }
.game-over .winner-name { color: var(--gold); font-size: 1.4em; font-weight: bold; }
.final-scores { margin: 15px 0; }

/* Rules */
.rules-content {
  background: white; border-radius: 12px; padding: 30px 36px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin: 15px 0;
  max-width: 800px; margin-left: auto; margin-right: auto;
  line-height: 1.6; font-size: 0.95em;
}
.rules-title {
  text-align: center; font-size: 2em; color: var(--gold-dark);
  margin-bottom: 2px;
}
.rules-subtitle {
  text-align: center; font-size: 1.05em; color: var(--brown-light);
  margin-bottom: 8px;
}
.rules-flavor {
  text-align: center; color: var(--brown-light); font-size: 0.95em;
  margin-bottom: 12px;
}
.rules-divider {
  border: none; border-top: 3px solid var(--gold-light); margin: 20px 0;
}
.rules-content h3 {
  color: var(--gold-dark); font-size: 1.4em; margin-top: 18px; margin-bottom: 8px;
}
.rules-content h4 {
  color: var(--brown); font-size: 1.1em; margin-top: 14px; margin-bottom: 6px;
}
.rules-content ul, .rules-content ol {
  padding-left: 24px; margin-bottom: 10px;
}
.rules-content li { margin-bottom: 5px; }
.rules-content li ul { margin-top: 4px; }
.rules-content p { margin-bottom: 10px; }
.rules-table {
  width: 100%; border-collapse: collapse; margin: 12px 0;
  font-size: 0.95em;
}
.rules-table th, .rules-table td {
  padding: 8px 14px; text-align: left;
  border-bottom: 1px solid #eee;
}
.rules-table th {
  background: var(--gold-light); color: var(--brown); font-weight: bold;
}
.rules-table tr:nth-child(even) { background: #FAFAFA; }
.rules-ref {
  background: var(--bg2); border-radius: 8px; padding: 12px 18px;
  border: 2px solid var(--gold-light);
}
.rules-ref p { margin-bottom: 4px; }
.rules-tips li { margin-bottom: 8px; }
.rules-card-sample {
  float: right; margin: 0 0 12px 20px; text-align: center;
}
.rules-card-sample img {
  width: 160px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.15);
}
.rules-card-sample .caption {
  font-size: 0.8em; color: var(--brown-light); margin-top: 4px; font-style: italic;
}
/* Hex layout diagram */
.hex-diagram {
  display: flex; justify-content: center; margin: 20px 0; clear: both;
}
.hex-grid {
  position: relative; width: 280px; height: 280px;
}
.hex-slot {
  position: absolute; width: 72px; height: 64px;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  font-size: 0.75em; font-weight: bold; border-radius: 8px;
  border: 3px solid #bbb; background: var(--cream);
  transform: translate(-50%, -50%);
}
.hex-slot .hex-num {
  font-size: 0.85em; background: var(--gold); color: white;
  border-radius: 8px; padding: 0 5px; margin-bottom: 2px;
}
.hex-slot .hex-label { color: var(--brown-light); font-size: 0.85em; }
.hex-slot.slot-1 { top: 8%; left: 50%; border-color: var(--gold); box-shadow: 0 0 6px rgba(218,165,32,0.4); }
.hex-slot.slot-2 { top: 28%; left: 85%; }
.hex-slot.slot-3 { top: 68%; left: 85%; }
.hex-slot.slot-4 { top: 88%; left: 50%; }
.hex-slot.slot-5 { top: 68%; left: 15%; }
.hex-slot.slot-6 { top: 28%; left: 15%; }
.hex-center {
  position: absolute; top: 48%; left: 50%; transform: translate(-50%, -50%);
  width: 68px; height: 68px; border-radius: 50%;
  background: linear-gradient(135deg, var(--gold), var(--orange));
  display: flex; align-items: center; justify-content: center;
  color: white; font-weight: bold; font-size: 0.7em; text-align: center;
  box-shadow: 0 2px 8px rgba(218,165,32,0.5);
}

/* Attr colors - matching card art order */
.attr-c0 { color: #757575; } /* Texture - gray */
.attr-c1 { color: #6D4C41; } /* Antennae - brown */
.attr-c2 { color: #D32F2F; } /* Weapon - red */
.attr-c3 { color: #1565C0; } /* Pattern - blue */
.attr-c4 { color: #2E7D32; } /* Wings - green */
.attr-c5 { color: #BF8C00; } /* Payload - gold */
.attr-bg0 { background: #F5F5F5; }
.attr-bg1 { background: #EFEBE9; }
.attr-bg2 { background: #FFEBEE; }
.attr-bg3 { background: #E3F2FD; }
.attr-bg4 { background: #E8F5E9; }
.attr-bg5 { background: #FFF8E1; }
</style>
</head>
<body>
<div id="app">
  <h1>Eye of the Bee-holder <small>A bee beauty pageant card game for 2-5 players</small></h1>
  <div class="tabs">
    <div class="tab active" onclick="switchTab('play')">Play Game</div>
    <div class="tab" onclick="switchTab('simulate')">Simulate</div>
    <div class="tab" onclick="switchTab('rules')">Rules</div>
  </div>
  <div id="play-screen" class="screen active"></div>
  <div id="sim-screen" class="screen"></div>
  <div id="rules-screen" class="screen">
    <div class="rules-content">

      <h2 class="rules-title">Eye of the Bee-holder</h2>
      <p class="rules-subtitle">A bee beauty pageant card game for 2&ndash;5 players | 30 minutes</p>
      <p class="rules-flavor"><em>In the bee world, beauty is in the eye of the bee-holder! Compete to present the most desirable bees according to the Queen's ever-changing standards. Draft the criteria, play your best bees, and manipulate what the hive considers beautiful.</em></p>

      <hr class="rules-divider">

      <h3>Components</h3>
      <ul>
        <li><strong>64 Bee Cards</strong> &mdash; each with a unique combination of 6 attributes</li>
        <li><strong>6 Double-Sided Facet Tiles</strong> &mdash; one per attribute, showing the Queen's current preference</li>
        <li><strong>1 Queen's Favor Tile</strong> &mdash; determines first player and breaks ties</li>
      </ul>

      <h3>Bee Attributes</h3>
      <p>Each bee card has 6 binary attributes. A bee has one trait or the other:</p>
      <table class="rules-table">
        <tr><th>Attribute</th><th colspan="2"></th></tr>
        <tr><td>Texture</td><td class="attr-c0">Fuzzy</td><td class="attr-c0">Shiny</td></tr>
        <tr><td>Antennae</td><td class="attr-c1">Feathered</td><td class="attr-c1">Whips</td></tr>
        <tr><td>Weapon</td><td class="attr-c2">Stinger</td><td class="attr-c2">Mandibles</td></tr>
        <tr><td>Pattern</td><td class="attr-c3">Striped</td><td class="attr-c3">Solid</td></tr>
        <tr><td>Wings</td><td class="attr-c4">Sleek</td><td class="attr-c4">Flutter</td></tr>
        <tr><td>Payload</td><td class="attr-c5">Honey</td><td class="attr-c5">Pollen</td></tr>
      </table>
      <div class="rules-card-sample">
        <img src="cards/card_00.png" alt="Pollen-Packed Velvet-Pincer">
        <div class="caption">Pollen-Packed Velvet-Pincer</div>
      </div>
      <p>Every possible combination of these 6 attributes appears on exactly one card, giving 64 unique bees. Each card shows the bee's name, illustration, and its six attribute icons along the left edge.</p>

      <h3>Facet Tiles</h3>
      <p>Each facet tile is double-sided, corresponding to one attribute &mdash; one trait per side. The face-up side shows which value the Queen currently desires for that attribute.</p>
      <p>During the game, facet tiles are arranged in a circle around the Queen's Favor tile. Position matters: the tile nearest the player the Queen's Favor points to is <strong>Slot 1</strong> (most important), and slots are numbered clockwise from there through <strong>Slot 6</strong> (least important).</p>

      <div style="text-align:center;margin:20px 0">
        <img src="rules_layout_diagram.png" alt="Facet tile layout around Queen's Favor" style="max-width:400px;width:100%;border-radius:8px;">
      </div>

      <hr class="rules-divider">

      <h3>Setup</h3>
      <ol>
        <li><strong>Place the 6 facet tiles</strong> in the center of the table.</li>
        <li><strong>Place the Queen's Favor</strong> in the center of the table, pointing to a random player.</li>
        <li><strong>Shuffle all 64 bee cards</strong> and deal <strong>7 cards</strong> to each player. Set remaining cards aside. Players look at their hands but keep them secret.</li>
        <li><strong>Draft the Queen's Favor</strong> (see below).</li>
      </ol>

      <h3>Overview</h3>
      <p>The game is played over a series of <strong>hands</strong>, each consisting of <strong>7 rounds</strong> (one per card in hand). Each round has three phases:</p>
      <ul>
        <li><strong>Present</strong> &mdash; All players simultaneously play a bee card face-down, then reveal.</li>
        <li><strong>Judge</strong> &mdash; The played bees are compared against the facet tiles to determine a winner.</li>
        <li><strong>Manipulate</strong> &mdash; Each player takes one action to alter the facet tiles.</li>
      </ul>
      <p>After all 7 rounds, check for a winner. If no one has won yet, deal a new hand and continue.</p>

      <hr class="rules-divider">

      <h3>Drafting the Queen's Favor</h3>
      <p>At the start of each hand, players draft the 6 facet tiles into specific positions around the Queen's Favor tile. Drafting determines which attributes occupy each slot and which side is face-up.</p>
      <p>The player that the Queen's Favor tile is pointing towards will draft <strong>last</strong>. Proceeding counter-clockwise from them, players take turns choosing from among the remaining attribute tiles, choosing one side to be face-up, and adding them around the Queen's Favor tile in the slots near them.</p>

      <h4>Drafting by Player Count</h4>
      <table class="rules-table">
        <tr><th>Players</th><th>Drafting Order</th></tr>
        <tr><td><strong>2</strong></td><td>Players alternate picking from Slot 6 down to Slot 1. First player drafts Slots 6, 4, 2. Other player drafts Slots 5, 3, 1.</td></tr>
        <tr><td><strong>3</strong></td><td>First player drafts Slots 6, 5. Next player drafts Slots 4, 3. Last player drafts Slots 2, 1.</td></tr>
        <tr><td><strong>4</strong></td><td>First player drafts Slots 6, 5. Next drafts Slots 4, 3. Next drafts Slot 2. Last drafts Slot 1.</td></tr>
        <tr><td><strong>5</strong></td><td>First player drafts Slots 6, 5. Remaining players each draft 1 slot (4, 3, 2, 1) in counter-clockwise order.</td></tr>
      </table>

      <hr class="rules-divider">

      <h3>Playing a Round</h3>

      <h4>Phase 1: Present</h4>
      <p>All players simultaneously choose one bee card from their hand and place it <strong>face-down</strong> in front of them. Once everyone has chosen, flip all cards face-up.</p>

      <h4>Phase 2: Judge</h4>
      <p>Compare the played bees against the facet tiles, starting from Slot 1:</p>
      <ol>
        <li><strong>Check Slot 1.</strong> Does the played bee match the desired attribute value on this tile?
          <ul>
            <li>If <strong>some bees match and others don't</strong>: eliminate all non-matching bees.</li>
            <li>If <strong>no bees match</strong>: skip this slot (all bees survive).</li>
            <li>If <strong>one bee remains</strong>: that bee wins. Stop judging.</li>
          </ul>
        </li>
        <li><strong>Repeat</strong> for Slot 2, then Slot 3, and so on through Slot 6. This will always result in a single winning bee.</li>
      </ol>
      <p>The winning player scores <strong>1 point</strong> for the round.</p>

      <h4>Phase 3: Manipulate</h4>
      <p>Starting with the player that won this round and proceeding clockwise, each player takes <strong>one action</strong>, either:</p>
      <ul>
        <li><strong>Flip</strong> one facet tile to its opposite side, OR</li>
        <li><strong>Swap</strong> the positions of any two facet tiles around the Queen's Favor.</li>
      </ul>
      <p><strong>Restriction:</strong> You cannot repeat the exact action taken by the player immediately before you. (You may perform the same type of action on different tiles.)</p>
      <p>After all players have taken an action, the round is over. Begin the next round with Phase 1.</p>
      <p><em>Note: The Manipulate phase is skipped after the final round (round 7) of each hand, since the facet tiles will be re-drafted for the next hand.</em></p>

      <hr class="rules-divider">

      <h3>Winning the Game</h3>
      <p>After completing a hand (all 7 rounds), count each player's total score pile. <strong>The first player to reach 10 points wins.</strong></p>
      <ul>
        <li>If <strong>one player</strong> has 10 or more points and leads outright: that player wins!</li>
        <li>If <strong>multiple players</strong> are tied at 10 or more points: enter <strong>Sudden Death</strong>.</li>
        <li>If <strong>no player</strong> has 10 points yet: deal a new hand and continue.</li>
      </ul>

      <h3>Sudden Death</h3>
      <p>Shuffle all cards, deal a new hand of 7, and draft the Queen's Favor as normal. Play rounds one at a time. After each round's <strong>Judge</strong> phase, check: does any single player now lead outright? If so, that player wins immediately. Otherwise, proceed to Manipulation as normal. If players remain tied at the top, keep playing.</p>

      <h3>Between Hands</h3>
      <p>When a hand ends without a winner:</p>
      <ol>
        <li>The player with the most points starts with the Queen's Favor (rotate the tile to point to them).</li>
        <li>Shuffle all 64 cards together, deal 7 to each player, and set the rest aside.</li>
        <li>Draft the attribute tiles around the Queen's Favor again.</li>
      </ol>

      <hr class="rules-divider">

      <h3>Quick Reference</h3>
      <div class="rules-ref">
        <p><strong>Round structure:</strong> Present (simultaneous) &rarr; Judge (Slot 1 through 6) &rarr; Manipulate (flip or swap)</p>
        <p><strong>Judging priority:</strong> Slot 1 &gt; Slot 2 &gt; Slot 3 &gt; Slot 4 &gt; Slot 5 &gt; Slot 6</p>
        <p><strong>Manipulation actions:</strong> Flip 1 tile OR swap 2 tiles. Cannot repeat the previous player's exact action.</p>
        <p><strong>Win condition:</strong> First to 10 points with a clear lead.</p>
      </div>

      <hr class="rules-divider">

      <h3>Strategy Tips</h3>
      <ul class="rules-tips">
        <li><strong>During the draft:</strong> Place your strongest attributes in the slots you control. Remember, Slot 1 dominates &mdash; if your best card matches Slot 1, it beats cards that match Slots 2&ndash;6 but miss Slot 1.</li>
        <li><strong>When presenting:</strong> Play the card that survives the most filters. A card matching Slots 1 and 2 will beat a card matching Slots 3, 4, 5, and 6.</li>
        <li><strong>Manipulation is key:</strong> A well-timed flip or swap before the next round can transform a weak hand into a winning one. Think about which changes help your remaining cards while hurting opponents.</li>
        <li><strong>Watch the endgame:</strong> As players approach 10 points, sudden death tension rises. Controlling Slot 1 through manipulation becomes critical.</li>
        <li><strong>Drafting trade-offs:</strong> By drafting first it may feel like you're just choosing tiebreakers, but you're choosing which tiles <em>will not</em> be eligible to be in the first few spots.</li>
      </ul>

    </div>
  </div>
</div>
<script>
// ============================================================
// CONSTANTS
// ============================================================
const ATTRIBUTES = [
  { name: 'Texture', values: ['Fuzzy', 'Shiny'], short: ['Fuz', 'Shi'] },
  { name: 'Antennae', values: ['Feathered', 'Whips'], short: ['Fea', 'Whi'] },
  { name: 'Weapon', values: ['Stinger', 'Mandibles'], short: ['Sti', 'Man'] },
  { name: 'Pattern', values: ['Striped', 'Solid'], short: ['Str', 'Sol'] },
  { name: 'Wings', values: ['Sleek', 'Flutter'], short: ['Slk', 'Flu'] },
  { name: 'Payload', values: ['Honey', 'Pollen'], short: ['Hon', 'Pol'] },
];

// Card data from data.csv: [id, name, [attr0..attr5]]
// id = row index in CSV = card_XX.png file number
// attrs: 0=Fuzzy/Feathered/Stinger/Striped/Sleek/Honey, 1=Shiny/Whips/Mandibles/Solid/Flutter/Pollen
const CARD_DATA_RAW = [
[0,"Pollen-Packed Velvet-Pincer",[0,1,1,1,0,1]],
[1,"Pollen-Dusted Chrome-Jaw",[1,1,1,1,0,1]],
[2,"Honey-Dipped Fluff-Whisk",[0,1,0,1,0,0]],
[3,"Amber Flutter-Fern",[1,0,1,0,1,0]],
[4,"Pollen-Packed Steel-Dart",[1,1,0,0,0,1]],
[5,"Honey-Soaked Fuzzy-Snapper",[0,1,1,0,0,0]],
[6,"Golden Plume-Spike",[1,0,0,1,1,0]],
[7,"Honey-Coated Chrome-Plume",[1,0,0,1,0,0]],
[8,"Honey-Striped Bolt-Fern",[1,0,0,0,0,0]],
[9,"Amber Wing-Chomp",[1,0,1,1,1,0]],
[10,"Pollen-Puffed Velvet-Pincer",[0,1,1,0,1,1]],
[11,"Dust-Covered Plush-Crunch",[0,0,1,0,0,1]],
[12,"Powder-Striped Frond-Needle",[0,0,0,0,0,1]],
[13,"Spore-Coated Ribbon-Lance",[0,1,0,1,0,1]],
[14,"Downy Wing-Barb",[0,0,0,1,1,1]],
[15,"Dusty Metal-Nipper",[1,1,1,0,1,1]],
[16,"Polished Plume-Prong",[1,0,0,0,0,1]],
[17,"Nectar-Drenched Fuzz-Point",[0,0,0,1,0,0]],
[18,"Powder-Kissed Gleaming-Bite",[1,0,1,0,1,1]],
[19,"Armored Frond-Snap",[1,0,1,1,1,1]],
[20,"Syrup-Glazed Whirl-Spike",[1,1,0,1,1,0]],
[21,"Lustrous Leaf-Barb",[1,0,0,1,0,1]],
[22,"Cottony Brush-Munch",[0,0,1,0,1,1]],
[23,"Nectar-Soaked Tuft-Dart",[0,0,0,0,1,0]],
[24,"Powder-Lashed Blade-Jaw",[1,1,1,0,0,1]],
[25,"Velvet Fern-Spike",[0,0,0,1,0,1]],
[26,"Glaze-Banded Slick-Pincer",[1,1,1,0,0,0]],
[27,"Soft Fan-Crunch",[0,0,1,1,0,1]],
[28,"Nectar-Striped Swirl-Lance",[1,1,0,0,1,0]],
[29,"Syrup-Dipped Curl-Snap",[0,1,1,1,0,0]],
[30,"Powdery Frond-Chomp",[0,0,1,1,1,1]],
[31,"Burnished Lash-Bite",[1,1,1,1,1,1]],
[32,"Dust-Banded Fluff-Needle",[0,1,0,0,1,1]],
[33,"Spore-Striped Plume-Point",[0,0,0,0,1,1]],
[34,"Golden Whisk-Nipper",[0,1,1,0,1,0]],
[35,"Amber Tassel-Prong",[0,0,0,1,1,0]],
[36,"Mirror-Bright Fan-Spike",[1,0,0,1,1,1]],
[37,"Powder-Laced Razor-Snap",[1,0,1,0,0,1]],
[38,"Honey-Banded Ribbon-Dart",[0,1,0,0,1,0]],
[39,"Nectar-Filled Woolly-Jaw",[0,0,1,1,1,0]],
[40,"Gloss-Coated Brush-Pincer",[1,0,1,1,0,0]],
[41,"Golden Tendril-Crunch",[1,1,1,1,1,0]],
[42,"Syrup-Banded Whip-Munch",[1,1,1,0,1,0]],
[43,"Honey-Laced Swift-Chomp",[1,0,1,0,0,0]],
[44,"Powder-Glossed Plumelet-Bite",[1,0,1,1,0,1]],
[45,"Dusty Coil-Barb",[0,1,0,1,1,1]],
[46,"Nectar-Brushed Plush-Snap",[0,0,1,1,0,0]],
[47,"Honey-Slicked Wire-Nipper",[1,1,1,1,0,0]],
[48,"Syrup-Striped Downy-Pincer",[0,0,1,0,0,0]],
[49,"Spore-Banded Antenna-Jaw",[0,1,1,0,0,1]],
[50,"Amber Feather-Bite",[0,0,1,0,1,0]],
[51,"Powder-Puffed Lasso-Snap",[0,1,1,1,1,1]],
[52,"Glaze-Soaked Wing-Lance",[0,1,0,1,1,0]],
[53,"Honey-Ringed Whip-Point",[0,1,0,0,0,0]],
[54,"Dust-Striped Curl-Needle",[0,1,0,0,0,1]],
[55,"Nectar-Banded Fern-Dart",[0,0,0,0,0,0]],
[56,"Spore-Laced Metallic-Prong",[1,1,0,0,1,1]],
[57,"Pollen-Coated Gleam-Barb",[1,1,0,1,1,1]],
[58,"Powder-Slicked Chrome-Needle",[1,1,0,1,0,1]],
[59,"Dusty Plume-Lance",[1,0,0,0,1,1]],
[60,"Nectar-Polished Razor-Point",[1,1,0,1,0,0]],
[61,"Glaze-Striped Lash-Dart",[1,1,0,0,0,0]],
[62,"Honey-Whipped Flutter-Chomp",[0,1,1,1,1,0]],
[63,"Amber-Striped Wing-Needle",[1,0,0,0,1,0]]
];
const CARD_DATA = {};
for (const [id, name, attrs] of CARD_DATA_RAW) {
  CARD_DATA[id] = { name, attrs, image: 'cards/card_' + String(id).padStart(2, '0') + '.png' };
}

const STRATEGIES = ['random','greedy','strategic','defensive','adaptive'];
const STRATEGY_NAMES = {
  random: 'Random', greedy: 'Greedy', strategic: 'Strategic',
  defensive: 'Defensive', adaptive: 'Adaptive'
};
const STRATEGY_DESC = {
  random: 'Picks cards and actions randomly',
  greedy: 'Plays the card that best matches current facets',
  strategic: 'Plans ahead considering manipulation options',
  defensive: 'Focuses on blocking the leader',
  adaptive: 'Switches between greedy and defensive based on score'
};

// ============================================================
// UTILITY
// ============================================================
function shuffle(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function getBit(cardId, attrIndex) {
  return CARD_DATA[cardId].attrs[attrIndex];
}

function getBeeName(cardId) {
  return CARD_DATA[cardId] ? CARD_DATA[cardId].name : 'Unknown Bee';
}

function getCardImage(cardId) {
  return CARD_DATA[cardId] ? CARD_DATA[cardId].image : '';
}

function getAttrValue(cardId, attrIndex) {
  return ATTRIBUTES[attrIndex].values[getBit(cardId, attrIndex)];
}

function cardMatchesFacet(cardId, facet) {
  return getBit(cardId, facet.attrIndex) === facet.desiredValue;
}

function scoreCard(cardId, facets) {
  // Higher = better. Weighted by slot importance.
  let score = 0;
  for (let i = 0; i < 6; i++) {
    if (cardMatchesFacet(cardId, facets[i])) {
      score += (1 << (5 - i)); // slot 1 = 32, slot 2 = 16, ..., slot 6 = 1
    }
  }
  return score;
}

function actionsEqual(a, b) {
  if (!a || !b) return false;
  if (a.type !== b.type) return false;
  if (a.type === 'flip') return a.slot === b.slot;
  if (a.type === 'swap') {
    const [a1, a2] = [Math.min(a.slotA, a.slotB), Math.max(a.slotA, a.slotB)];
    const [b1, b2] = [Math.min(b.slotA, b.slotB), Math.max(b.slotA, b.slotB)];
    return a1 === b1 && a2 === b2;
  }
  return false;
}

// ============================================================
// GAME ENGINE
// ============================================================
class BeeGame {
  constructor(playerConfigs) {
    this.players = playerConfigs.map((c, i) => ({
      name: c.name,
      isHuman: c.isHuman,
      strategy: c.strategy || 'random',
      hand: [],
      score: 0,
      index: i,
    }));
    this.numPlayers = this.players.length;
    this.facets = new Array(6).fill(null); // facets[0] = slot 1
    this.qfPlayer = Math.floor(Math.random() * this.numPlayers);
    this.hand = 0;
    this.roundInHand = 0;
    this.suddenDeath = false;
    this.phase = 'deal'; // deal, draft, present, judge, manipulate, handEnd, gameOver
    this.draftSequence = [];
    this.draftStep = 0;
    this.availableTiles = [];
    this.playedCards = [];
    this.judgeResult = null;
    this.manipOrder = [];
    this.manipStep = 0;
    this.lastManipAction = null;
    this.roundWinner = -1;
    this.winner = -1;
    this.log = [];
  }

  addLog(msg, important = false) {
    this.log.push({ msg, important });
  }

  startHand() {
    this.hand++;
    this.roundInHand = 0;
    // Deal
    const deck = shuffle([...Array(64).keys()]);
    for (let i = 0; i < this.numPlayers; i++) {
      this.players[i].hand = deck.slice(i * 7, (i + 1) * 7);
    }
    // Reset facets
    this.facets = new Array(6).fill(null);
    this.availableTiles = [0, 1, 2, 3, 4, 5]; // attribute indices
    this.draftSequence = this.getDraftSequence();
    this.draftStep = 0;
    this.phase = 'draft';
    this.addLog(`--- Hand ${this.hand} begins ---`, true);
    this.addLog(`Queen's Favor points to ${this.players[this.qfPlayer].name}`);
  }

  getDraftSequence() {
    // Counter-clockwise from QF holder = decreasing player indices (mod numPlayers)
    const ccw = [];
    for (let i = 1; i < this.numPlayers; i++) {
      ccw.push((this.qfPlayer - i + this.numPlayers) % this.numPlayers);
    }
    ccw.push(this.qfPlayer);

    const seq = [];
    switch (this.numPlayers) {
      case 2:
        seq.push({ player: ccw[0], slot: 6 });
        seq.push({ player: ccw[1], slot: 5 });
        seq.push({ player: ccw[0], slot: 4 });
        seq.push({ player: ccw[1], slot: 3 });
        seq.push({ player: ccw[0], slot: 2 });
        seq.push({ player: ccw[1], slot: 1 });
        break;
      case 3:
        seq.push({ player: ccw[0], slot: 6 }, { player: ccw[0], slot: 5 });
        seq.push({ player: ccw[1], slot: 4 }, { player: ccw[1], slot: 3 });
        seq.push({ player: ccw[2], slot: 2 }, { player: ccw[2], slot: 1 });
        break;
      case 4:
        seq.push({ player: ccw[0], slot: 6 }, { player: ccw[0], slot: 5 });
        seq.push({ player: ccw[1], slot: 4 }, { player: ccw[1], slot: 3 });
        seq.push({ player: ccw[2], slot: 2 });
        seq.push({ player: ccw[3], slot: 1 });
        break;
      case 5:
        seq.push({ player: ccw[0], slot: 6 }, { player: ccw[0], slot: 5 });
        seq.push({ player: ccw[1], slot: 4 });
        seq.push({ player: ccw[2], slot: 3 });
        seq.push({ player: ccw[3], slot: 2 });
        seq.push({ player: ccw[4], slot: 1 });
        break;
    }
    return seq;
  }

  getCurrentDraft() {
    if (this.draftStep >= this.draftSequence.length) return null;
    return this.draftSequence[this.draftStep];
  }

  draftTile(attrIndex, desiredValue) {
    const draft = this.getCurrentDraft();
    if (!draft) return;
    const slotIdx = draft.slot - 1; // 0-indexed
    this.facets[slotIdx] = { attrIndex, desiredValue };
    this.availableTiles = this.availableTiles.filter(a => a !== attrIndex);
    const p = this.players[draft.player];
    const val = ATTRIBUTES[attrIndex].values[desiredValue];
    this.addLog(`${p.name} drafts ${ATTRIBUTES[attrIndex].name} (${val}) to Slot ${draft.slot}`);
    this.draftStep++;
    if (this.draftStep >= this.draftSequence.length) {
      this.phase = 'present';
      this.startRound();
    }
  }

  startRound() {
    this.roundInHand++;
    this.playedCards = new Array(this.numPlayers).fill(-1);
    this.judgeResult = null;
    this.addLog(`Round ${this.roundInHand} of 7`, true);
  }

  presentCard(playerIndex, cardId) {
    this.playedCards[playerIndex] = cardId;
    // Remove from hand
    this.players[playerIndex].hand = this.players[playerIndex].hand.filter(c => c !== cardId);
  }

  allPresented() {
    return this.playedCards.every(c => c >= 0);
  }

  judge() {
    let remaining = this.playedCards.map((cardId, idx) => ({ playerIndex: idx, cardId }));
    const steps = [];

    for (let slot = 0; slot < 6; slot++) {
      const facet = this.facets[slot];
      const matching = remaining.filter(p => cardMatchesFacet(p.cardId, facet));
      const nonMatching = remaining.filter(p => !cardMatchesFacet(p.cardId, facet));

      if (matching.length > 0 && nonMatching.length > 0) {
        steps.push({
          slot: slot + 1,
          facet,
          eliminated: nonMatching.map(p => p.playerIndex),
          survived: matching.map(p => p.playerIndex),
        });
        remaining = matching;
      } else {
        steps.push({
          slot: slot + 1,
          facet,
          eliminated: [],
          survived: remaining.map(p => p.playerIndex),
          skipped: matching.length === 0,
        });
      }

      if (remaining.length === 1) {
        break;
      }
    }

    const winner = remaining[0].playerIndex;
    this.judgeResult = { winner, steps };
    // Award 1 point per round win
    this.players[winner].score += 1;
    this.roundWinner = winner;

    this.addLog(`${this.players[winner].name} wins the round! (+1 pt, total: ${this.players[winner].score})`);
    for (const step of steps) {
      if (step.eliminated.length > 0) {
        const names = step.eliminated.map(i => this.players[i].name).join(', ');
        this.addLog(`  Slot ${step.slot} (${ATTRIBUTES[step.facet.attrIndex].values[step.facet.desiredValue]}): eliminated ${names}`);
      } else if (step.skipped) {
        this.addLog(`  Slot ${step.slot}: skipped (no matches)`);
      }
    }

    // Determine what phase comes next after the judge results are shown
    if (this.suddenDeath) {
      const result = this.checkWinner();
      if (result) {
        this.phase = 'gameOver';
        this.winner = result.winner;
        this.addLog(`${this.players[this.winner].name} wins the game in sudden death!`, true);
        return this.judgeResult;
      }
    }

    if (this.roundInHand >= 7) {
      // Last round of hand: skip manipulation, go straight to handEnd
      this.judgeResult.skipManip = true;
    }

    this.phase = 'judge';
    return this.judgeResult;
  }

  startManipulate() {
    this.phase = 'manipulate';
    // Order: winner first, then clockwise
    this.manipOrder = [];
    for (let i = 0; i < this.numPlayers; i++) {
      this.manipOrder.push((this.roundWinner + i) % this.numPlayers);
    }
    this.manipStep = 0;
    this.lastManipAction = null;
  }

  getCurrentManipulator() {
    if (this.manipStep >= this.manipOrder.length) return -1;
    return this.manipOrder[this.manipStep];
  }

  isValidManipulation(action) {
    if (action.type === 'flip') {
      if (action.slot < 0 || action.slot > 5) return false;
    } else if (action.type === 'swap') {
      if (action.slotA < 0 || action.slotA > 5 || action.slotB < 0 || action.slotB > 5) return false;
      if (action.slotA === action.slotB) return false;
    } else {
      return false;
    }
    // Check restriction: can't repeat previous player's exact action
    if (this.manipStep > 0 && actionsEqual(action, this.lastManipAction)) {
      return false;
    }
    return true;
  }

  getValidManipulations() {
    const valid = [];
    // All flips
    for (let i = 0; i < 6; i++) {
      const a = { type: 'flip', slot: i };
      if (this.isValidManipulation(a)) valid.push(a);
    }
    // All swaps
    for (let i = 0; i < 6; i++) {
      for (let j = i + 1; j < 6; j++) {
        const a = { type: 'swap', slotA: i, slotB: j };
        if (this.isValidManipulation(a)) valid.push(a);
      }
    }
    return valid;
  }

  applyManipulation(action) {
    const pIdx = this.getCurrentManipulator();
    if (pIdx < 0) return;

    if (action.type === 'flip') {
      this.facets[action.slot].desiredValue = 1 - this.facets[action.slot].desiredValue;
      const f = this.facets[action.slot];
      this.addLog(`${this.players[pIdx].name} flips ${ATTRIBUTES[f.attrIndex].name} to ${ATTRIBUTES[f.attrIndex].values[f.desiredValue]}`);
    } else if (action.type === 'swap') {
      [this.facets[action.slotA], this.facets[action.slotB]] = [this.facets[action.slotB], this.facets[action.slotA]];
      this.addLog(`${this.players[pIdx].name} swaps Slot ${action.slotA + 1} and Slot ${action.slotB + 1}`);
    }

    this.lastManipAction = action;
    this.manipStep++;

    if (this.manipStep >= this.manipOrder.length) {
      this.endRound();
    }
  }

  endRound() {
    // Note: sudden death winner check and last-round skip are handled in judge().
    // endRound is only called after manipulation completes (mid-hand rounds).
    if (this.roundInHand >= 7) {
      this.phase = 'handEnd';
    } else {
      this.phase = 'present';
      this.startRound();
    }
  }

  checkWinner() {
    const maxScore = Math.max(...this.players.map(p => p.score));
    if (maxScore < 10) return null;
    const leaders = this.players.filter(p => p.score === maxScore);
    if (leaders.length === 1) {
      return { winner: leaders[0].index, suddenDeath: false };
    }
    return null; // Tied
  }

  resolveHandEnd() {
    const result = this.checkWinner();
    if (result) {
      this.phase = 'gameOver';
      this.winner = result.winner;
      this.addLog(`${this.players[this.winner].name} wins the game!`, true);
      return 'gameOver';
    }
    const maxScore = Math.max(...this.players.map(p => p.score));
    if (maxScore >= 10) {
      // Multiple players tied at 10+, enter sudden death
      this.suddenDeath = true;
      this.addLog('Tied at 10+! Entering Sudden Death!', true);
    }
    // Next hand
    // Player with most points gets QF
    const leader = this.players.reduce((a, b) => a.score > b.score ? a : b);
    this.qfPlayer = leader.index;
    this.startHand();
    return 'newHand';
  }

  // Serialize minimal state for AI decisions
  getState() {
    return {
      facets: this.facets.map(f => ({ ...f })),
      scores: this.players.map(p => p.score),
      numPlayers: this.numPlayers,
      roundInHand: this.roundInHand,
      suddenDeath: this.suddenDeath,
      roundWinner: this.roundWinner,
      playedCards: [...this.playedCards],
    };
  }
}

// ============================================================
// AI
// ============================================================
const AI = {
  chooseDraft(strategy, hand, availableTiles, slotNum, existingFacets) {
    // Count how many cards in hand have each attribute value
    const attrCounts = availableTiles.map(attrIdx => {
      const count0 = hand.filter(c => getBit(c, attrIdx) === 0).length;
      const count1 = hand.filter(c => getBit(c, attrIdx) === 1).length;
      return { attrIdx, count0, count1, max: Math.max(count0, count1), side: count1 > count0 ? 1 : 0 };
    });

    switch (strategy) {
      case 'random': {
        const tile = availableTiles[Math.floor(Math.random() * availableTiles.length)];
        return { attrIndex: tile, desiredValue: Math.random() < 0.5 ? 0 : 1 };
      }
      case 'defensive': {
        // Pick the attribute that is most evenly split (hardest for opponents)
        attrCounts.sort((a, b) => Math.abs(a.count0 - a.count1) - Math.abs(b.count0 - b.count1));
        const pick = attrCounts[0];
        return { attrIndex: pick.attrIdx, desiredValue: pick.side };
      }
      default: {
        // Greedy/strategic/adaptive: pick attribute where we have the most matching cards
        attrCounts.sort((a, b) => b.max - a.max);
        const pick = attrCounts[0];
        return { attrIndex: pick.attrIdx, desiredValue: pick.side };
      }
    }
  },

  chooseCard(strategy, hand, facets, gameState) {
    if (hand.length === 0) return -1;
    if (hand.length === 1) return hand[0];

    switch (strategy) {
      case 'random':
        return hand[Math.floor(Math.random() * hand.length)];

      case 'greedy': {
        // Pick card with highest score against current facets
        let bestCard = hand[0], bestScore = -1;
        for (const c of hand) {
          const s = scoreCard(c, facets);
          if (s > bestScore) { bestScore = s; bestCard = c; }
        }
        return bestCard;
      }

      case 'strategic': {
        // Evaluate each card considering what manipulation we could do afterward
        // For each card, consider the best manipulation and score the resulting board
        // for our remaining hand
        let bestCard = hand[0], bestValue = -Infinity;
        for (const card of hand) {
          const cardScore = scoreCard(card, facets);
          // Simulate: what's our best remaining hand value after optimal manipulation?
          const remaining = hand.filter(c => c !== card);
          let bestManipValue = 0;
          // Try all possible manipulations
          for (let s = 0; s < 6; s++) {
            // Try flip
            const flipped = facets.map(f => ({...f}));
            flipped[s] = {...flipped[s], desiredValue: 1 - flipped[s].desiredValue};
            const flipBest = remaining.length > 0 ? Math.max(...remaining.map(c => scoreCard(c, flipped))) : 0;
            bestManipValue = Math.max(bestManipValue, flipBest);
            // Try swaps
            for (let s2 = s + 1; s2 < 6; s2++) {
              const swapped = facets.map(f => ({...f}));
              [swapped[s], swapped[s2]] = [swapped[s2], swapped[s]];
              const swapBest = remaining.length > 0 ? Math.max(...remaining.map(c => scoreCard(c, swapped))) : 0;
              bestManipValue = Math.max(bestManipValue, swapBest);
            }
          }
          // Combined value: current card score + future potential (discounted)
          const value = cardScore * 2 + bestManipValue;
          if (value > bestValue) {
            bestValue = value;
            bestCard = card;
          }
        }
        return bestCard;
      }

      case 'defensive': {
        // Always play best card, but prioritize matching slot 1 above all else
        const scored = hand.map(c => {
          let s = scoreCard(c, facets);
          // Heavy bonus for matching slot 1
          if (cardMatchesFacet(c, facets[0])) s += 100;
          // Bonus for matching slot 2
          if (cardMatchesFacet(c, facets[1])) s += 20;
          return { card: c, score: s };
        });
        scored.sort((a, b) => b.score - a.score);
        return scored[0].card;
      }

      case 'adaptive': {
        const maxOtherScore = Math.max(...gameState.scores.filter((_, i) => i !== gameState.myIndex));
        const myScore = gameState.scores[gameState.myIndex];
        if (myScore >= maxOtherScore) {
          return AI.chooseCard('greedy', hand, facets, gameState);
        }
        return AI.chooseCard('strategic', hand, facets, gameState);
      }

      default:
        return hand[Math.floor(Math.random() * hand.length)];
    }
  },

  chooseManipulation(strategy, hand, facets, gameState, validActions) {
    if (validActions.length === 0) return null;

    switch (strategy) {
      case 'random':
        return validActions[Math.floor(Math.random() * validActions.length)];

      case 'greedy': {
        // Try each action, pick the one that maximizes best card score
        let bestAction = validActions[0], bestScore = -1;
        for (const action of validActions) {
          const testFacets = facets.map(f => ({ ...f }));
          if (action.type === 'flip') {
            testFacets[action.slot] = { ...testFacets[action.slot], desiredValue: 1 - testFacets[action.slot].desiredValue };
          } else {
            [testFacets[action.slotA], testFacets[action.slotB]] = [testFacets[action.slotB], testFacets[action.slotA]];
          }
          const maxCardScore = Math.max(...hand.map(c => scoreCard(c, testFacets)));
          if (maxCardScore > bestScore) {
            bestScore = maxCardScore;
            bestAction = action;
          }
        }
        return bestAction;
      }

      case 'strategic': {
        // Maximize average of top 2 remaining cards
        let bestAction = validActions[0], bestAvg = -1;
        for (const action of validActions) {
          const testFacets = facets.map(f => ({ ...f }));
          if (action.type === 'flip') {
            testFacets[action.slot] = { ...testFacets[action.slot], desiredValue: 1 - testFacets[action.slot].desiredValue };
          } else {
            [testFacets[action.slotA], testFacets[action.slotB]] = [testFacets[action.slotB], testFacets[action.slotA]];
          }
          const scores = hand.map(c => scoreCard(c, testFacets)).sort((a, b) => b - a);
          const avg = (scores[0] + (scores[1] || 0)) / Math.min(2, scores.length);
          if (avg > bestAvg) {
            bestAvg = avg;
            bestAction = action;
          }
        }
        return bestAction;
      }

      case 'defensive': {
        // Try to minimize the leader's advantage
        // Find the facet configuration that most hurts high-slot matches for common attributes
        // Simple: flip slot 1 or 2 if it's not helping us
        const flips = validActions.filter(a => a.type === 'flip' && a.slot <= 1);
        if (flips.length > 0) {
          // Flip a high-priority slot to disrupt opponents
          for (const flip of flips) {
            const myBest = Math.max(...hand.map(c => scoreCard(c, facets)));
            const testFacets = facets.map(f => ({ ...f }));
            testFacets[flip.slot] = { ...testFacets[flip.slot], desiredValue: 1 - testFacets[flip.slot].desiredValue };
            const myBestAfter = Math.max(...hand.map(c => scoreCard(c, testFacets)));
            if (myBestAfter >= myBest - 4) return flip; // Don't hurt ourselves too much
          }
        }
        // Fallback to greedy
        return AI.chooseManipulation('greedy', hand, facets, gameState, validActions);
      }

      case 'adaptive': {
        const maxOtherScore = Math.max(...gameState.scores.filter((_, i) => i !== gameState.myIndex));
        const myScore = gameState.scores[gameState.myIndex];
        if (myScore < maxOtherScore) {
          return AI.chooseManipulation('defensive', hand, facets, gameState, validActions);
        }
        return AI.chooseManipulation('strategic', hand, facets, gameState, validActions);
      }

      default:
        return validActions[Math.floor(Math.random() * validActions.length)];
    }
  }
};

// ============================================================
// UI STATE
// ============================================================
let game = null;
let uiState = {
  screen: 'setup',
  selectedCard: -1,
  selectedDraftTile: -1,
  manipMode: null, // 'flip' or 'swap'
  swapFirst: -1,
  passAndPlayReady: false,
  currentHumanPresenter: -1,
  autoAdvanceTimer: null,
  aiSpeed: 600, // ms delay for AI actions
};

// ============================================================
// UI RENDERING
// ============================================================
function switchTab(tab) {
  const tabs = ['play', 'simulate', 'rules'];
  document.querySelectorAll('.tab').forEach((t, i) => {
    t.classList.toggle('active', tabs[i] === tab);
  });
  document.getElementById('play-screen').classList.toggle('active', tab === 'play');
  document.getElementById('sim-screen').classList.toggle('active', tab === 'simulate');
  document.getElementById('rules-screen').classList.toggle('active', tab === 'rules');
  if (tab === 'simulate') renderSimScreen();
}

function renderPlayScreen() {
  const el = document.getElementById('play-screen');
  if (uiState.screen === 'setup') {
    renderSetup(el);
  } else if (uiState.screen === 'game') {
    renderGame(el);
  }
}

function renderSetup(el) {
  const defaultPlayers = [
    { name: 'You', isHuman: true, strategy: 'greedy' },
    { name: 'BeeBot', isHuman: false, strategy: 'greedy' },
    { name: 'BuzzAI', isHuman: false, strategy: 'strategic' },
  ];
  if (!uiState.setupPlayers) uiState.setupPlayers = defaultPlayers;

  let html = `<div class="setup-section"><h2>Game Setup</h2>`;
  html += `<div style="margin-bottom:10px">
    <label>Number of Players: </label>
    <select id="num-players" onchange="changePlayerCount(this.value)">
      ${[2,3,4,5].map(n => `<option value="${n}" ${n === uiState.setupPlayers.length ? 'selected' : ''}>${n}</option>`).join('')}
    </select>
  </div>`;

  for (let i = 0; i < uiState.setupPlayers.length; i++) {
    const p = uiState.setupPlayers[i];
    html += `<div class="player-row">
      <label>Player ${i + 1}:</label>
      <input type="text" value="${p.name}" onchange="uiState.setupPlayers[${i}].name=this.value" style="width:120px">
      <select onchange="changePlayerType(${i}, this.value)">
        <option value="human" ${p.isHuman ? 'selected' : ''}>Human</option>
        <option value="ai" ${!p.isHuman ? 'selected' : ''}>AI</option>
      </select>
      ${!p.isHuman ? `<select onchange="uiState.setupPlayers[${i}].strategy=this.value">
        ${STRATEGIES.map(s => `<option value="${s}" ${p.strategy === s ? 'selected' : ''}>${STRATEGY_NAMES[s]}</option>`).join('')}
      </select>
      <span style="font-size:0.8em;color:#999">${STRATEGY_DESC[p.strategy]}</span>` : ''}
    </div>`;
  }

  html += `<div class="btn-group">
    <button class="btn btn-primary" onclick="startGame()">Start Game</button>
  </div></div>`;

  // Rules reference
  html += `<div class="setup-section"><h2>How to Play</h2>
    <p style="font-size:0.9em;line-height:1.5">
      <b>Draft</b> facet tiles to set what the Queen considers beautiful.<br>
      <b>Present</b> a bee card each round. <b>Judge</b> bees by checking facets from Slot 1 (most important) to Slot 6.<br>
      <b>Manipulate</b> tiles by flipping or swapping after each round.<br>
      First to <b>10 points</b> with a clear lead wins! Each round, the winner gets all played cards (1 point each).
    </p>
  </div>`;

  el.innerHTML = html;
}

function changePlayerCount(n) {
  n = parseInt(n);
  while (uiState.setupPlayers.length < n) {
    const i = uiState.setupPlayers.length;
    uiState.setupPlayers.push({ name: `AI-${i + 1}`, isHuman: false, strategy: STRATEGIES[i % STRATEGIES.length] });
  }
  while (uiState.setupPlayers.length > n) uiState.setupPlayers.pop();
  renderPlayScreen();
}

function changePlayerType(i, type) {
  uiState.setupPlayers[i].isHuman = (type === 'human');
  if (!uiState.setupPlayers[i].isHuman && !uiState.setupPlayers[i].strategy) {
    uiState.setupPlayers[i].strategy = 'greedy';
  }
  renderPlayScreen();
}

function startGame() {
  game = new BeeGame(uiState.setupPlayers);
  uiState.screen = 'game';
  game.startHand();
  renderPlayScreen();
  scheduleAdvance();
}

function renderGame(el) {
  if (!game) return;
  let html = '';

  // Header
  const phaseNames = {
    draft: 'Drafting Phase',
    present: 'Present a Bee',
    judge: 'Judging',
    manipulate: 'Manipulation Phase',
    handEnd: 'Hand Complete',
    gameOver: 'Game Over'
  };
  const sdLabel = game.suddenDeath ? ' [SUDDEN DEATH]' : '';
  html += `<div class="game-header">
    <div>
      <div class="phase-info">${phaseNames[game.phase] || game.phase}${sdLabel}</div>
      <div class="round-info">Hand ${game.hand} | Round ${game.roundInHand} of 7</div>
    </div>
  </div>`;

  // Scores
  html += `<div class="scores-bar">`;
  for (const p of game.players) {
    const isWinner = game.phase === 'gameOver' && game.winner === p.index;
    const isCurrent = getCurrentActivePlayer() === p.index;
    html += `<div class="score-chip ${isWinner ? 'winner' : ''} ${isCurrent ? 'current' : ''}">
      <span class="name">${p.name}</span>: <span class="pts">${p.score} pts</span>
      ${!p.isHuman ? `<span class="strategy-tag">[${STRATEGY_NAMES[p.strategy]}]</span>` : ''}
      ${game.qfPlayer === p.index ? ' &#x1F451;' : ''}
    </div>`;
  }
  html += `</div>`;

  // Game Over
  if (game.phase === 'gameOver') {
    html += renderGameOver();
    html += renderLog();
    el.innerHTML = html;
    return;
  }

  // Hand End
  if (game.phase === 'handEnd') {
    html += `<div class="action-area">
      <h3>Hand ${game.hand} Complete</h3>
      <p>Scores after this hand:</p>
      <div style="margin:10px 0">${game.players.map(p => `<b>${p.name}</b>: ${p.score} pts`).join(' | ')}</div>
      <button class="btn btn-primary" onclick="resolveHandEnd()">Continue to Next Hand</button>
    </div>`;
    html += renderLog();
    el.innerHTML = html;
    return;
  }

  // Board (facets)
  html += renderFacets();

  // Phase-specific content
  if (game.phase === 'draft') {
    html += renderDraft();
  } else if (game.phase === 'present') {
    html += renderPresent();
  } else if (game.phase === 'judge') {
    html += renderJudge();
  } else if (game.phase === 'manipulate') {
    html += renderManipulate();
  }

  // Hand (for human players, show current human's hand during present/manipulate)
  const humanIdx = getActiveHumanIndex();
  if (humanIdx >= 0 && game.phase !== 'judge') {
    html += renderHand(humanIdx);
  }

  // Log
  html += renderLog();

  el.innerHTML = html;
}

function getCurrentActivePlayer() {
  if (game.phase === 'draft') {
    const d = game.getCurrentDraft();
    return d ? d.player : -1;
  }
  if (game.phase === 'present') return uiState.currentHumanPresenter;
  if (game.phase === 'manipulate') return game.getCurrentManipulator();
  return -1;
}

function getActiveHumanIndex() {
  if (game.phase === 'present') return uiState.currentHumanPresenter;
  if (game.phase === 'manipulate') {
    const m = game.getCurrentManipulator();
    return (m >= 0 && game.players[m].isHuman) ? m : -1;
  }
  if (game.phase === 'draft') {
    const d = game.getCurrentDraft();
    return (d && game.players[d.player].isHuman) ? d.player : -1;
  }
  return -1;
}

function renderFacets() {
  let html = `<div class="facets-container"><h3>Queen's Standards (Slot 1 = Most Important)</h3><div class="facets-row">`;
  for (let i = 0; i < 6; i++) {
    const f = game.facets[i];
    const isClickable = (game.phase === 'manipulate' && getActiveHumanIndex() >= 0);
    const isSelected = (uiState.swapFirst === i);
    const slotClass = i === 0 ? 'slot-1' : (i === 1 ? 'slot-2' : '');
    const clickable = isClickable ? 'clickable' : '';
    const selected = isSelected ? 'selected' : '';

    if (f) {
      const attr = ATTRIBUTES[f.attrIndex];
      const val = attr.values[f.desiredValue];
      html += `<div class="facet-tile ${slotClass} ${clickable} ${selected} attr-bg${f.attrIndex}"
        ${isClickable ? `onclick="facetClick(${i})"` : ''}>
        <span class="slot-num">${i + 1}</span>
        <div class="attr-name">${attr.name}</div>
        <div class="attr-value attr-c${f.attrIndex}">${val}</div>
      </div>`;
    } else {
      html += `<div class="facet-tile ${slotClass}">
        <span class="slot-num">${i + 1}</span>
        <div class="attr-name">---</div>
        <div class="attr-value">Empty</div>
      </div>`;
    }
  }
  html += `</div>`;
  html += `<div class="qf-indicator">Queen's Favor: ${game.players[game.qfPlayer].name}</div>`;
  html += `</div>`;
  return html;
}

function renderDraft() {
  const draft = game.getCurrentDraft();
  if (!draft) return '';
  const p = game.players[draft.player];

  if (!p.isHuman) {
    return `<div class="action-area">
      <h3>${p.name} is drafting for Slot ${draft.slot}...</h3>
    </div>`;
  }

  let html = `<div class="action-area">
    <h3>${p.name}: Choose a tile for Slot ${draft.slot}</h3>
    <p>Pick an attribute tile and choose which side faces up.</p>`;

  if (uiState.selectedDraftTile < 0) {
    html += `<div class="draft-tiles">`;
    for (const attrIdx of game.availableTiles) {
      const attr = ATTRIBUTES[attrIdx];
      html += `<div class="draft-tile attr-bg${attrIdx}" onclick="selectDraftTile(${attrIdx})">
        <div class="dt-name attr-c${attrIdx}">${attr.name}</div>
        <div style="font-size:0.8em">${attr.values[0]} / ${attr.values[1]}</div>
      </div>`;
    }
    html += `</div>`;
  } else {
    const attr = ATTRIBUTES[uiState.selectedDraftTile];
    html += `<p>Selected: <b class="attr-c${uiState.selectedDraftTile}">${attr.name}</b>
      <button class="btn btn-small btn-secondary" onclick="uiState.selectedDraftTile=-1;renderPlayScreen()">Change</button></p>`;
    html += `<p>Choose which side faces up:</p>`;
    html += `<div class="side-choice">
      <div class="side-btn attr-bg${uiState.selectedDraftTile}" onclick="confirmDraft(0)">
        <span class="attr-c${uiState.selectedDraftTile}">${attr.values[0]}</span>
      </div>
      <div class="side-btn attr-bg${uiState.selectedDraftTile}" onclick="confirmDraft(1)">
        <span class="attr-c${uiState.selectedDraftTile}">${attr.values[1]}</span>
      </div>
    </div>`;
  }
  html += `</div>`;
  return html;
}

function renderPresent() {
  const humanIdx = uiState.currentHumanPresenter;

  // Check if we need pass-and-play
  const humanCount = game.players.filter(p => p.isHuman).length;
  if (humanIdx >= 0 && humanCount > 1 && !uiState.passAndPlayReady) {
    return `<div class="action-area pass-screen">
      <h2>Pass to ${game.players[humanIdx].name}</h2>
      <p>Don't peek at the screen until you're ready!</p>
      <button class="btn btn-primary" onclick="uiState.passAndPlayReady=true;renderPlayScreen()">I'm Ready</button>
    </div>`;
  }

  if (humanIdx >= 0) {
    return `<div class="action-area">
      <h3>${game.players[humanIdx].name}: Choose a bee to present</h3>
      <p>Select a card from your hand and click "Present".</p>
      <button class="btn btn-primary" ${uiState.selectedCard < 0 ? 'disabled' : ''}
        onclick="humanPresentCard()">Present This Bee</button>
    </div>`;
  }

  return `<div class="action-area"><h3>AI players are choosing...</h3></div>`;
}

function renderJudge() {
  const jr = game.judgeResult;
  if (!jr) return '';

  let html = `<div class="action-area">
    <h3>Judging Results</h3>`;

  // Show played cards
  html += `<div class="played-area"><div class="played-cards-row">`;
  for (let i = 0; i < game.numPlayers; i++) {
    const cardId = game.playedCards[i];
    const isWinner = jr.winner === i;
    const isEliminated = !isWinner && jr.winner !== i;
    html += `<div class="played-card-wrapper">
      <div class="player-label">${game.players[i].name}</div>
      ${renderCardMini(cardId, isWinner ? 'winner' : (isEliminated ? 'eliminated' : ''), game.facets)}
    </div>`;
  }
  html += `</div></div>`;

  // Elimination steps
  html += `<div style="margin:10px 0;font-size:0.9em">`;
  for (const step of jr.steps) {
    const attr = ATTRIBUTES[step.facet.attrIndex];
    const val = attr.values[step.facet.desiredValue];
    if (step.eliminated.length > 0) {
      const names = step.eliminated.map(i => game.players[i].name).join(', ');
      html += `<div>Slot ${step.slot} (${attr.name}: ${val}): <span style="color:var(--red)">eliminated ${names}</span></div>`;
    } else if (step.skipped) {
      html += `<div>Slot ${step.slot} (${attr.name}: ${val}): <span style="color:#999">skipped (no matches)</span></div>`;
    } else {
      html += `<div>Slot ${step.slot} (${attr.name}: ${val}): <span style="color:var(--green)">all match</span></div>`;
    }
  }
  html += `</div>`;
  html += `<div style="font-size:1.1em;font-weight:bold;color:var(--gold-dark)">
    ${game.players[jr.winner].name} wins this round! (+1 pt)</div>`;
  if (jr.skipManip) {
    html += `<div style="margin-top:8px;font-size:0.9em;color:var(--brown-light)">Last round of the hand -- skipping manipulation.</div>`;
    html += `<button class="btn btn-primary" onclick="skipToHandEnd()" style="margin-top:10px">End Hand</button>`;
  } else {
    html += `<button class="btn btn-primary" onclick="proceedToManipulate()" style="margin-top:10px">Proceed to Manipulation</button>`;
  }
  html += `</div>`;
  return html;
}

function renderManipulate() {
  const mIdx = game.getCurrentManipulator();
  if (mIdx < 0) return '';
  const p = game.players[mIdx];

  let html = `<div class="action-area">
    <h3>Manipulation - ${p.name}'s turn</h3>`;

  if (game.lastManipAction) {
    const la = game.lastManipAction;
    const desc = la.type === 'flip'
      ? `Flip Slot ${la.slot + 1}`
      : `Swap Slot ${la.slotA + 1} & ${la.slotB + 1}`;
    html += `<div class="manip-info">Previous action (restricted): ${desc}</div>`;
  }

  if (p.isHuman) {
    html += `<p>Choose an action: flip one tile or swap two tiles.</p>`;
    html += `<div class="manip-modes">
      <div class="mode-btn ${uiState.manipMode === 'flip' ? 'active' : ''}" onclick="setManipMode('flip')">Flip a Tile</div>
      <div class="mode-btn ${uiState.manipMode === 'swap' ? 'active' : ''}" onclick="setManipMode('swap')">Swap Two Tiles</div>
    </div>`;

    if (uiState.manipMode === 'flip') {
      html += `<p>Click a facet tile above to flip it.</p>`;
    } else if (uiState.manipMode === 'swap') {
      if (uiState.swapFirst < 0) {
        html += `<p>Click the first tile to swap.</p>`;
      } else {
        html += `<p>Slot ${uiState.swapFirst + 1} selected. Click the second tile to swap with.</p>
          <button class="btn btn-small btn-secondary" onclick="uiState.swapFirst=-1;renderPlayScreen()">Cancel</button>`;
      }
    }
  } else {
    html += `<p>${p.name} is thinking...</p>`;
  }

  html += `</div>`;
  return html;
}

function renderHand(playerIdx) {
  const p = game.players[playerIdx];
  const hand = p.hand;
  let html = `<div class="hand-area"><h3>${p.name}'s Hand (${hand.length} cards)</h3><div class="cards-row">`;
  for (const cardId of hand) {
    const isSelected = uiState.selectedCard === cardId;
    const clickable = game.phase === 'present' && uiState.currentHumanPresenter === playerIdx;
    html += renderCard(cardId, isSelected, clickable, game.facets);
  }
  html += `</div></div>`;
  return html;
}

function renderCard(cardId, selected, clickable, facets) {
  const name = getBeeName(cardId);
  const img = getCardImage(cardId);
  const cls = `bee-card ${selected ? 'selected' : ''} ${clickable ? 'clickable' : ''}`;
  let html = `<div class="${cls}" ${clickable ? `onclick="selectCard(${cardId})"` : ''}>`;
  html += `<div class="bee-img"><img src="${img}" alt="${name}"></div>`;
  html += `<div class="bee-name">${name}</div><div class="attrs">`;
  for (let a = 0; a < 6; a++) {
    const val = getBit(cardId, a);
    const attr = ATTRIBUTES[a];
    let matchClass = '';
    if (facets && facets[0]) {
      const slotIdx = facets.findIndex(f => f && f.attrIndex === a);
      if (slotIdx >= 0) {
        matchClass = (facets[slotIdx].desiredValue === val) ? 'match' : 'mismatch';
      }
    }
    html += `<div class="attr-row ${matchClass}">
      <span class="a-label">${attr.name.substring(0,3)}</span>
      <span class="a-value attr-c${a}">${attr.values[val]}</span>
    </div>`;
  }
  if (facets && facets[0]) {
    html += `<div class="score-badge">Score: ${scoreCard(cardId, facets)}</div>`;
  }
  html += `</div></div>`;
  return html;
}

function renderCardMini(cardId, extraClass, facets) {
  const name = getBeeName(cardId);
  const img = getCardImage(cardId);
  let html = `<div class="bee-card mini ${extraClass}">`;
  html += `<div class="bee-img"><img src="${img}" alt="${name}"></div>`;
  html += `<div class="bee-name">${name}</div><div class="attrs">`;
  for (let a = 0; a < 6; a++) {
    const val = getBit(cardId, a);
    const attr = ATTRIBUTES[a];
    let matchClass = '';
    if (facets) {
      const slotIdx = facets.findIndex(f => f && f.attrIndex === a);
      if (slotIdx >= 0) {
        matchClass = (facets[slotIdx].desiredValue === val) ? 'match' : 'mismatch';
      }
    }
    html += `<div class="attr-row ${matchClass}">
      <span class="a-label">${attr.name.substring(0,3)}</span>
      <span class="a-value attr-c${a}">${attr.values[val]}</span>
    </div>`;
  }
  html += `</div></div>`;
  return html;
}

function renderGameOver() {
  const w = game.players[game.winner];
  let html = `<div class="game-over">
    <h2>Game Over!</h2>
    <div class="winner-name">${w.name} Wins!</div>
    <div class="final-scores">`;
  const sorted = [...game.players].sort((a, b) => b.score - a.score);
  for (const p of sorted) {
    html += `<div style="margin:4px 0"><b>${p.name}</b>: ${p.score} pts
      ${!p.isHuman ? `[${STRATEGY_NAMES[p.strategy]}]` : '[Human]'}</div>`;
  }
  html += `</div>
    <div class="btn-group" style="justify-content:center">
      <button class="btn btn-primary" onclick="startGame()">Play Again</button>
      <button class="btn btn-secondary" onclick="uiState.screen='setup';uiState.setupPlayers=null;renderPlayScreen()">New Setup</button>
    </div>
  </div>`;
  return html;
}

function renderLog() {
  const entries = game.log.slice(-30);
  let html = `<div class="game-log"><h3>Game Log</h3>`;
  for (const e of entries) {
    html += `<div class="log-entry ${e.important ? 'important' : ''}">${e.msg}</div>`;
  }
  html += `</div>`;
  return html;
}

// ============================================================
// UI ACTIONS
// ============================================================
function selectDraftTile(attrIdx) {
  uiState.selectedDraftTile = attrIdx;
  renderPlayScreen();
}

function confirmDraft(side) {
  game.draftTile(uiState.selectedDraftTile, side);
  uiState.selectedDraftTile = -1;
  renderPlayScreen();
  scheduleAdvance();
}

function selectCard(cardId) {
  uiState.selectedCard = (uiState.selectedCard === cardId) ? -1 : cardId;
  renderPlayScreen();
}

function humanPresentCard() {
  if (uiState.selectedCard < 0) return;
  const pIdx = uiState.currentHumanPresenter;
  game.presentCard(pIdx, uiState.selectedCard);
  uiState.selectedCard = -1;
  uiState.passAndPlayReady = false;

  // Find next human presenter
  const nextHuman = findNextHumanPresenter(pIdx);
  if (nextHuman >= 0) {
    uiState.currentHumanPresenter = nextHuman;
    renderPlayScreen();
  } else {
    uiState.currentHumanPresenter = -1;
    // All presented, judge
    game.judge();
    renderPlayScreen();
  }
}

function findNextHumanPresenter(afterIdx) {
  for (let i = 0; i < game.numPlayers; i++) {
    const idx = (afterIdx + 1 + i) % game.numPlayers;
    if (idx === afterIdx) continue;
    if (game.players[idx].isHuman && game.playedCards[idx] < 0) return idx;
  }
  return -1;
}

function skipToHandEnd() {
  game.phase = 'handEnd';
  renderPlayScreen();
  // Auto-advance for all-AI games
  if (!game.players.some(p => p.isHuman)) {
    scheduleAdvance();
  }
}

function proceedToManipulate() {
  game.startManipulate();
  uiState.manipMode = null;
  uiState.swapFirst = -1;
  renderPlayScreen();
  scheduleAdvance();
}

function setManipMode(mode) {
  uiState.manipMode = mode;
  uiState.swapFirst = -1;
  renderPlayScreen();
}

function facetClick(slotIdx) {
  const mIdx = game.getCurrentManipulator();
  if (mIdx < 0 || !game.players[mIdx].isHuman) return;

  if (uiState.manipMode === 'flip') {
    const action = { type: 'flip', slot: slotIdx };
    if (game.isValidManipulation(action)) {
      game.applyManipulation(action);
      uiState.manipMode = null;
      uiState.swapFirst = -1;
      renderPlayScreen();
      scheduleAdvance();
    } else {
      alert('Cannot repeat the previous player\'s exact action!');
    }
  } else if (uiState.manipMode === 'swap') {
    if (uiState.swapFirst < 0) {
      uiState.swapFirst = slotIdx;
      renderPlayScreen();
    } else if (uiState.swapFirst === slotIdx) {
      uiState.swapFirst = -1;
      renderPlayScreen();
    } else {
      const action = { type: 'swap', slotA: uiState.swapFirst, slotB: slotIdx };
      if (game.isValidManipulation(action)) {
        game.applyManipulation(action);
        uiState.manipMode = null;
        uiState.swapFirst = -1;
        renderPlayScreen();
        scheduleAdvance();
      } else {
        alert('Cannot repeat the previous player\'s exact action!');
        uiState.swapFirst = -1;
        renderPlayScreen();
      }
    }
  }
}

function resolveHandEnd() {
  game.resolveHandEnd();
  renderPlayScreen();
  scheduleAdvance();
}

// ============================================================
// GAME ADVANCE (AI turns)
// ============================================================
function scheduleAdvance() {
  if (uiState.autoAdvanceTimer) clearTimeout(uiState.autoAdvanceTimer);
  uiState.autoAdvanceTimer = setTimeout(advanceGame, uiState.aiSpeed);
}

function advanceGame() {
  if (!game || game.phase === 'gameOver') return;
  if (game.phase === 'handEnd') {
    // Auto-advance for all-AI games
    if (!game.players.some(p => p.isHuman)) {
      resolveHandEnd();
    }
    return;
  }

  if (game.phase === 'draft') {
    const draft = game.getCurrentDraft();
    if (!draft) return;
    const p = game.players[draft.player];
    if (p.isHuman) { renderPlayScreen(); return; }
    // AI draft
    const choice = AI.chooseDraft(p.strategy, p.hand, game.availableTiles, draft.slot, game.facets);
    game.draftTile(choice.attrIndex, choice.desiredValue);
    renderPlayScreen();
    scheduleAdvance();
    return;
  }

  if (game.phase === 'present') {
    // AI players present cards
    for (let i = 0; i < game.numPlayers; i++) {
      if (!game.players[i].isHuman && game.playedCards[i] < 0) {
        const state = game.getState();
        state.myIndex = i;
        const cardId = AI.chooseCard(game.players[i].strategy, game.players[i].hand, game.facets, state);
        game.presentCard(i, cardId);
      }
    }
    // Check if we need human input
    const firstHuman = game.players.findIndex((p, i) => p.isHuman && game.playedCards[i] < 0);
    if (firstHuman >= 0) {
      uiState.currentHumanPresenter = firstHuman;
      renderPlayScreen();
      return; // Wait for human
    }
    // All presented, judge
    uiState.currentHumanPresenter = -1;
    game.judge();
    renderPlayScreen();
    // If no humans at all, auto-advance through judge
    if (!game.players.some(p => p.isHuman)) {
      setTimeout(() => {
        if (game.phase === 'judge') {
          if (game.judgeResult && game.judgeResult.skipManip) {
            skipToHandEnd();
          } else {
            proceedToManipulate();
          }
        }
      }, 100);
    }
    return;
  }

  if (game.phase === 'manipulate') {
    const mIdx = game.getCurrentManipulator();
    if (mIdx < 0) return;
    const p = game.players[mIdx];
    if (p.isHuman) { renderPlayScreen(); return; }
    // AI manipulate
    const validActions = game.getValidManipulations();
    const state = game.getState();
    state.myIndex = mIdx;
    const action = AI.chooseManipulation(p.strategy, p.hand, game.facets, state, validActions);
    if (action) game.applyManipulation(action);
    renderPlayScreen();
    // After AI manipulation, game may have advanced to present, handEnd, or gameOver
    if (game.phase === 'manipulate' || game.phase === 'present') {
      scheduleAdvance();
    } else {
      renderPlayScreen();
    }
    return;
  }
}

// ============================================================
// SIMULATION
// ============================================================
function renderSimScreen() {
  const el = document.getElementById('sim-screen');
  let html = `<div class="setup-section"><h2>Simulation Mode</h2>
    <p style="margin-bottom:12px;font-size:0.9em">Run many AI-only games to gather strategy statistics.</p>
    <div class="sim-config">
      <div class="sim-field">
        <label>Players</label>
        <select id="sim-num-players">
          ${[2,3,4,5].map(n => `<option value="${n}" ${n === 3 ? 'selected' : ''}>${n}</option>`).join('')}
        </select>
      </div>
      <div class="sim-field">
        <label>Games</label>
        <select id="sim-num-games">
          <option value="100">100</option>
          <option value="500" selected>500</option>
          <option value="1000">1000</option>
          <option value="5000">5000</option>
        </select>
      </div>
      <div class="sim-field">
        <label>Mode</label>
        <select id="sim-mode">
          <option value="roundrobin">Round Robin (all strategy combos)</option>
          <option value="custom">Custom matchup</option>
        </select>
      </div>
    </div>
    <div id="sim-custom-config" style="margin-top:10px;display:none"></div>
    <div class="btn-group">
      <button class="btn btn-primary" onclick="runSimulation()">Run Simulation</button>
      <button class="btn btn-danger btn-small" id="sim-stop-btn" onclick="stopSimulation()" style="display:none">Stop</button>
    </div>
  </div>
  <div id="sim-progress"></div>
  <div id="sim-results"></div>`;
  el.innerHTML = html;

  document.getElementById('sim-mode').addEventListener('change', function() {
    const custom = document.getElementById('sim-custom-config');
    if (this.value === 'custom') {
      const n = parseInt(document.getElementById('sim-num-players').value);
      let ch = '';
      for (let i = 0; i < n; i++) {
        ch += `<div class="sim-field" style="display:inline-flex;flex-direction:column;margin-right:8px">
          <label>Player ${i+1}</label>
          <select class="sim-custom-strat">
            ${STRATEGIES.map(s => `<option value="${s}">${STRATEGY_NAMES[s]}</option>`).join('')}
          </select>
        </div>`;
      }
      custom.innerHTML = ch;
      custom.style.display = 'block';
    } else {
      custom.style.display = 'none';
    }
  });
}

let simRunning = false;

function stopSimulation() {
  simRunning = false;
}

function runSimulation() {
  const numPlayers = parseInt(document.getElementById('sim-num-players').value);
  const numGames = parseInt(document.getElementById('sim-num-games').value);
  const mode = document.getElementById('sim-mode').value;

  let matchups = [];

  if (mode === 'roundrobin') {
    // Generate all combinations of strategies for numPlayers positions
    function combos(n, strats) {
      if (n === 0) return [[]];
      const sub = combos(n - 1, strats);
      const result = [];
      for (const s of strats) {
        for (const c of sub) result.push([s, ...c]);
      }
      return result;
    }
    matchups = combos(numPlayers, STRATEGIES);
  } else {
    const selects = document.querySelectorAll('.sim-custom-strat');
    const strats = Array.from(selects).map(s => s.value);
    matchups = [strats];
  }

  const gamesPerMatchup = mode === 'roundrobin'
    ? Math.max(1, Math.floor(numGames / matchups.length))
    : numGames;

  simRunning = true;
  document.getElementById('sim-stop-btn').style.display = 'inline-block';

  const results = [];
  let matchupIdx = 0;
  let gameInMatchup = 0;
  const totalGames = gamesPerMatchup * matchups.length;
  let completedGames = 0;

  const progressEl = document.getElementById('sim-progress');
  const resultsEl = document.getElementById('sim-results');

  function runBatch() {
    if (!simRunning) {
      finishSim();
      return;
    }
    const batchSize = 20;
    for (let b = 0; b < batchSize && matchupIdx < matchups.length; b++) {
      const strats = matchups[matchupIdx];
      const result = simulateOneGame(strats);
      results.push({ strats, result });
      completedGames++;
      gameInMatchup++;
      if (gameInMatchup >= gamesPerMatchup) {
        gameInMatchup = 0;
        matchupIdx++;
      }
    }

    const pct = Math.round(100 * completedGames / totalGames);
    progressEl.innerHTML = `<div class="progress-bar"><div class="progress-fill" style="width:${pct}%">${pct}%</div></div>
      <div style="text-align:center;font-size:0.85em">${completedGames} / ${totalGames} games</div>`;

    if (matchupIdx < matchups.length) {
      requestAnimationFrame(runBatch);
    } else {
      finishSim();
    }
  }

  function finishSim() {
    simRunning = false;
    document.getElementById('sim-stop-btn').style.display = 'none';
    resultsEl.innerHTML = analyzeSimResults(results, numPlayers);
  }

  requestAnimationFrame(runBatch);
}

function simulateOneGame(strategies) {
  const configs = strategies.map((s, i) => ({
    name: `P${i+1}-${s}`,
    isHuman: false,
    strategy: s,
  }));
  const g = new BeeGame(configs);
  g.addLog = () => {}; // Suppress logging for performance
  let safety = 0;

  g.startHand();

  while (g.phase !== 'gameOver' && safety < 1000) {
    safety++;

    if (g.phase === 'draft') {
      while (g.phase === 'draft') {
        const draft = g.getCurrentDraft();
        if (!draft) break;
        const p = g.players[draft.player];
        const choice = AI.chooseDraft(p.strategy, p.hand, g.availableTiles, draft.slot, g.facets);
        g.draftTile(choice.attrIndex, choice.desiredValue);
      }
    }

    if (g.phase === 'present') {
      for (let i = 0; i < g.numPlayers; i++) {
        if (g.playedCards[i] < 0) {
          const state = g.getState();
          state.myIndex = i;
          const cardId = AI.chooseCard(g.players[i].strategy, g.players[i].hand, g.facets, state);
          g.presentCard(i, cardId);
        }
      }
      g.judge();
    }

    // judge() may have set phase to 'gameOver' (sudden death win)
    if (g.phase === 'gameOver') continue;

    if (g.phase === 'judge') {
      if (g.judgeResult && g.judgeResult.skipManip) {
        // Last round of hand: skip manipulation
        g.phase = 'handEnd';
      } else {
        g.startManipulate();
      }
    }

    if (g.phase === 'manipulate') {
      while (g.phase === 'manipulate' && g.getCurrentManipulator() >= 0) {
        const mIdx = g.getCurrentManipulator();
        const p = g.players[mIdx];
        const validActions = g.getValidManipulations();
        const state = g.getState();
        state.myIndex = mIdx;
        const action = AI.chooseManipulation(p.strategy, p.hand, g.facets, state, validActions);
        if (action) g.applyManipulation(action);
        else break;
      }
    }

    if (g.phase === 'handEnd') {
      g.resolveHandEnd();
    }
  }

  return {
    winner: g.winner,
    winnerStrategy: g.winner >= 0 ? strategies[g.winner] : null,
    scores: g.players.map(p => p.score),
    hands: g.hand,
    suddenDeath: g.suddenDeath,
  };
}

function analyzeSimResults(results, numPlayers) {
  // Strategy win counts
  const stratWins = {};
  const stratGames = {};
  const stratScores = {};
  const stratPositionWins = {};

  for (const s of STRATEGIES) {
    stratWins[s] = 0;
    stratGames[s] = 0;
    stratScores[s] = [];
    for (let p = 0; p < numPlayers; p++) {
      if (!stratPositionWins[s]) stratPositionWins[s] = {};
      stratPositionWins[s][p] = { wins: 0, games: 0 };
    }
  }

  let totalHands = 0;
  let totalSuddenDeath = 0;

  for (const { strats, result } of results) {
    totalHands += result.hands;
    if (result.suddenDeath) totalSuddenDeath++;

    for (let i = 0; i < strats.length; i++) {
      const s = strats[i];
      stratGames[s]++;
      stratScores[s].push(result.scores[i]);
      stratPositionWins[s][i].games++;
      if (result.winner === i) {
        stratWins[s]++;
        stratPositionWins[s][i].wins++;
      }
    }
  }

  let html = `<div class="setup-section sim-results"><h2>Results (${results.length} games)</h2>`;
  html += `<p style="margin-bottom:10px;font-size:0.9em">
    Avg game length: ${(totalHands / results.length).toFixed(1)} hands |
    Sudden death rate: ${(100 * totalSuddenDeath / results.length).toFixed(1)}%
  </p>`;

  // Strategy performance table
  html += `<table><tr><th>Strategy</th><th>Games</th><th>Wins</th><th>Win Rate</th><th>Avg Score</th><th>Avg Winning Score</th></tr>`;
  const stratArr = STRATEGIES.filter(s => stratGames[s] > 0);
  stratArr.sort((a, b) => (stratWins[b] / stratGames[b]) - (stratWins[a] / stratGames[a]));

  for (const s of stratArr) {
    const winRate = (100 * stratWins[s] / stratGames[s]).toFixed(1);
    const avgScore = (stratScores[s].reduce((a, b) => a + b, 0) / stratScores[s].length).toFixed(1);
    const winningScores = [];
    for (const { strats, result } of results) {
      for (let i = 0; i < strats.length; i++) {
        if (strats[i] === s && result.winner === i) winningScores.push(result.scores[i]);
      }
    }
    const avgWinScore = winningScores.length > 0
      ? (winningScores.reduce((a, b) => a + b, 0) / winningScores.length).toFixed(1) : '-';

    const barWidth = Math.round(parseFloat(winRate));
    html += `<tr>
      <td><b>${STRATEGY_NAMES[s]}</b></td>
      <td>${stratGames[s]}</td>
      <td>${stratWins[s]}</td>
      <td>
        <div style="display:flex;align-items:center;gap:6px">
          <div style="width:100px;height:16px;background:#eee;border-radius:8px;overflow:hidden">
            <div style="width:${barWidth}%;height:100%;background:var(--gold);border-radius:8px"></div>
          </div>
          ${winRate}%
        </div>
      </td>
      <td>${avgScore}</td>
      <td>${avgWinScore}</td>
    </tr>`;
  }
  html += `</table>`;

  // Head-to-head (only for 2-player custom matchups)
  if (numPlayers === 2 && results.length > 0) {
    html += `<h3 style="margin-top:15px">Head-to-Head Matchups</h3>`;
    const h2h = {};
    for (const { strats, result } of results) {
      const key = `${strats[0]} vs ${strats[1]}`;
      if (!h2h[key]) h2h[key] = { p1wins: 0, p2wins: 0, total: 0, s1: strats[0], s2: strats[1] };
      h2h[key].total++;
      if (result.winner === 0) h2h[key].p1wins++;
      else h2h[key].p2wins++;
    }
    html += `<table><tr><th>Matchup</th><th>P1 Wins</th><th>P2 Wins</th><th>P1 Win %</th></tr>`;
    for (const [key, data] of Object.entries(h2h)) {
      if (data.total < 2) continue;
      html += `<tr>
        <td>${STRATEGY_NAMES[data.s1]} vs ${STRATEGY_NAMES[data.s2]}</td>
        <td>${data.p1wins}</td><td>${data.p2wins}</td>
        <td>${(100 * data.p1wins / data.total).toFixed(1)}%</td>
      </tr>`;
    }
    html += `</table>`;
  }

  // Position advantage
  html += `<h3 style="margin-top:15px">Win Rate by Seat Position</h3>`;
  html += `<table><tr><th>Position</th>`;
  for (let p = 0; p < numPlayers; p++) html += `<th>Seat ${p + 1}</th>`;
  html += `</tr>`;
  // Overall position win rate
  const posWins = new Array(numPlayers).fill(0);
  const posGames = new Array(numPlayers).fill(0);
  for (const { result } of results) {
    for (let i = 0; i < numPlayers; i++) posGames[i]++;
    if (result.winner >= 0) posWins[result.winner]++;
  }
  html += `<tr><td><b>Overall</b></td>`;
  for (let p = 0; p < numPlayers; p++) {
    html += `<td>${posGames[p] > 0 ? (100 * posWins[p] / posGames[p]).toFixed(1) + '%' : '-'}</td>`;
  }
  html += `</tr></table>`;

  html += `</div>`;
  return html;
}

// ============================================================
// INIT
// ============================================================
renderPlayScreen();
</script>
</body>
</html>
